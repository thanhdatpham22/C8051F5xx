//-----------------------------------------------------------------------------
// Includes
//-----------------------------------------------------------------------------

#include <compiler_defs.h>
#include <C8051F580_defs.h>        // SFR declarations

//-----------------------------------------------------------------------------
// Function Prototypes
//-----------------------------------------------------------------------------

void OSCILLATOR_Init (void);
void PORT_Init (void);
void CAN0_Init (void);
void Timer0_Init(void);
void delay_ms(unsigned int ms);
void CAN0_Transmit_Polling(void);
//INTERRUPT_PROTO(CAN0_ISR, INTERRUPT_CAN0);

//-----------------------------------------------------------------------------
// Global Constants
//-----------------------------------------------------------------------------

#define SYSCLK       24000000          // System clock speed in Hz

#define MESSAGE_OBJECTS    1          // Number of message objects to use
                                       // Range is 1-32
#define MESSAGE_SIZE        8          // Size in bytes of each CAN message
                                       // Range is 1-8



//-----------------------------------------------------------------------------
// Bit Definition Masks
//-----------------------------------------------------------------------------

// CAN0STAT
#define BOff  0x80                     // Busoff Status
#define EWarn 0x40                     // Warning Status
#define EPass 0x20                     // Error Passive
#define RxOk  0x10                     // Receive Message Successfully
#define TxOk  0x08                     // Transmitted Message Successfully
#define LEC   0x07                     // Last Error Code

//-----------------------------------------------------------------------------
// Pin Definitions
//-----------------------------------------------------------------------------

SBIT(LED, SFR_P2, 0);                 // LED = 1 turns on the LED

//-----------------------------------------------------------------------------
// Global Variables
//-----------------------------------------------------------------------------

bit CAN_ERROR = 0;                     // 0 == No Errors during transmission
                                       // 1 == Some error(s) occurred
U8 buffer[8] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,};

U8 obj_num;                    // Message object counter
volatile unsigned long timeout_counter = 0;
//-----------------------------------------------------------------------------
// SiLabs_Startup() Routine
// ----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
void SiLabs_Startup (void)
{
   PCA0MD &= ~0x40;                    // Disable Watchdog Timer
}

//-----------------------------------------------------------------------------
// MAIN Routine
//-----------------------------------------------------------------------------

void main (void)
{
   SFRPAGE = ACTIVE_PAGE;             // Set for PCA0MD
	
	SiLabs_Startup();
   OSCILLATOR_Init ();                 // Initialize oscillator
   PORT_Init ();                       // Initialize crossbar and GPIO
   CAN0_Init ();						// Start CAN peripheral
   Timer0_Init();                       
   

   //EIE2 |= 0x02;                       // Enable CAN interupts
   //IE_EA = 1;                          // Enable global interrupts
   EIE2 &= ~0x02;                     // Disable CAN interrupts
   EA = 1;                         // Disable global interrupts

   CAN_ERROR = 0;
   //LED = 0;


   while (1)
     {

         CAN0_Transmit_Polling();
		 LED = !LED;
		 delay_ms(1000);
     }

}
void OSCILLATOR_Init (void)
{
   U8 SFRPAGE_save = SFRPAGE;
   SFRPAGE = CONFIG_PAGE;

   OSCICN = 0x87;                      // Set internal oscillator divider to 1

   SFRPAGE = SFRPAGE_save;
}


void PORT_Init (void)
{
   U8 SFRPAGE_save = SFRPAGE;
   SFRPAGE = CONFIG_PAGE;              // Port SFR's on Configuration page

   P0MDOUT |= 0x40;                    // P0.6 (CAN0 TX) is push-pull
   P2MDOUT |= 0x01;                    // P1.3 (LED) is push-pull

   XBR0 = 0x02;                        // Enable CAN0 on Crossbar
   XBR2 = 0x40;                        // Enable Crossbar and weak pull-ups

   SFRPAGE = SFRPAGE_save;
}

//-----------------------------------------------------------------------------
// CAN0_Init
//-----------------------------------------------------------------------------

void CAN0_Init (void)
{
   U8 SFRPAGE_save = SFRPAGE;
   SFRPAGE = CAN0_PAGE;                // All CAN register are on page 0x0C

   CAN0CN |= 0x01;                     // Start Intialization mode

   //---------Initialize general CAN peripheral settings

   CAN0CN |= 0x4E;                     // Enable Status, Error, Module Interrupts,Enable access to bit timing register

   // See the CAN Bit Timing Spreadsheet for how to calculate this value
   CAN0BT = 0x1402;                    // Based on 24 Mhz CAN clock, set the // CAN bit rate 1402 to 1 Mbps, 1405 to 500k bps

   //---------Initialize settings common to all message objects
   // Command Mask Register
   CAN0IF1CM = 0x00F0;                 // Write Operation, Transfer ID Mask, MDir, Transfer ID, Dir, Xtd, MsgVal,Transfer Control Bits, Don't set TxRqst or transfer data

   // Mask Registers
   CAN0IF1M1 = 0x0000;                 // Mask Bits 15-0 not used for filtering
   CAN0IF1M2 = 0x5FFC;                 // Ignore Extended Identifier for
                                       // filtering
                                       // Used Direction bit for filtering
                                       // Use ID bits 28-18 for filtering
   // Arbitration Registers
   CAN0IF1A1 = 0x0000;                 // 11-bit ID, so lower 16-bits not used

   // Message Control Registers
   CAN0IF1MC = 0x1480 | MESSAGE_SIZE;  // Enable Transmit Interrupt
                                       // Message Object is a Single Message
                                       // Message Size set by #define

   //---------Initialize unique settings for each valid message object
  CAN0IF1A2 = 0xA000 |(0x31C);                 // MsgVal valid, Direction = transmit, ID = 0
  CAN0IF1CR = 0;                      // Write to Message Object 0
  while (CAN0IF1CRH & 0x80) {}        // Wait for Busy bit to clear

   CAN0IF1A2 = 0x0000;              // Set MsgVal = 0 to ignore
   CAN0CN &= ~0x01;                    // Return to Normal Mode (chi xóa bit Init)
   SFRPAGE = SFRPAGE_save;
}

void CAN0_Transmit_Polling(void)
{

    U8 SFRPAGE_save = SFRPAGE;
    SFRPAGE = CAN0_PAGE;                // All CAN registers are on page 0x0C
    CAN0IF1DA1L = buffer[0];  // Byte 0
    CAN0IF1DA1H = buffer[1];  // Byte 1
    CAN0IF1DA2L = buffer[2];  // Byte 2
    CAN0IF1DA2H = buffer[3];  // Byte 3
    CAN0IF1DB1L = buffer[4];  // Byte 4
    CAN0IF1DB1H = buffer[5];  // Byte 5
    CAN0IF1DB2L = buffer[6];  // Byte 6
    CAN0IF1DB2H = buffer[7];  // Byte 7

    CAN0IF1CM = 0x0087;            // Set Direction to Write
                                          // Write TxRqst, all 8 data bytes
    CAN0IF1CR = 0x00;          // Start command request
    // Wait for command to complete
    while (CAN0IF1CRH & 0x80) {}  // Poll on Busy bit
    // Wait for transmission to complete by polling CAN0STAT
    while (!(CAN0STAT & TxOk))    // Wait until transmission is successful
    {
        if (CAN0STAT & (BOff | LEC))  // Check for bus-off or last error code
        {
            CAN_ERROR = 1;        // Set error flag
            LED = 0;              // Turn off LED to indicate error
            break;                // Exit polling loop on error
        }
    }
    // Update LED status based on transmission result
    if (!CAN_ERROR)
    {
        LED = 1;                  // Turn on LED to indicate success
    }
    else
    {
        LED = 0;                  // Turn off LED if error occurred
    }
    SFRPAGE = SFRPAGE_save;
}
void Timer0_Init(void)
{
	
	TMOD &= 0xF0;
	TMOD |= 0x01; // timer 16bit
	CKCON |= 0x02;  // SYSCLK/48 = 500 kHz
	TH0 = (65536 - 500) >> 8;
	TL0 = (655536 -500) & 0xFF;
    ET0 = 1;               
    TR0 = 1;               
}
INTERRUPT(Timer0_ISR, INTERRUPT_TIMER0)
{	
	TH0 = (65536 - 500) >> 8;
    TL0 = (65536 - 500) & 0xFF;

    timeout_counter++;
}

void delay_ms(unsigned int ms)
{
    unsigned long start = timeout_counter;
    while ((timeout_counter - start) < ms);
}
//-----------------------------------------------------------------------------
// Interrupt Service Routines
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// End Of File
//-----------------------------------------------------------------------------
