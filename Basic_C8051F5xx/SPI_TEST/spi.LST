C51 COMPILER V9.54   SPI                                                                   04/18/2025 16:51:39 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE SPI
OBJECT MODULE PLACED IN spi.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.exe spi.c DB OE BR INCDIR(c:\SiLabs\MCU_4\Inc)

line level    source

   1          #include <compiler_defs.h>
   2          #include <C8051F580_defs.h> 
   3          
   4          #include "timer.h"
*** WARNING C323 IN LINE 11 OF timer.h: newline expected, extra characters found
   5          #include "spi.h"
*** WARNING C323 IN LINE 20 OF spi.h: newline expected, extra characters found
   6          #define BAUDRATE           115200      // Baud rate of UART in bps
   7          #define SYSCLK             24000000 
   8          
   9          
  10          
  11          void SPI0_Init()
  12          {
  13   1         U8 SFRPAGE_save = SFRPAGE;
  14   1         SFRPAGE = ACTIVE_PAGE;
  15   1      
  16   1         SPI0CFG   = 0x40;                   // Enable the SPI as a Master
  17   1                                             // CKPHA = '0', CKPOL = '0'
  18   1      
  19   1         SPI0CN    = 0x0D;                   // 4-wire, single master mode
  20   1                                             // SPI0 enable
  21   1      
  22   1         // The equation for SPI0CKR is (SYSCLK/(2*F_SCK_MAX))-1, but this yields
  23   1         // a SPI frequency that is slightly more than 2 MHz. But, 2 MHz is the max
  24   1         // frequency spec of the EEPROM used here. So, the "-1" term is omitted
  25   1         // in the following usage:
  26   1         SPI0CKR   = (SYSCLK / (2 * F_SCK_MAX));
  27   1      
  28   1         SFRPAGE = SFRPAGE_save;
  29   1      }
  30          void EEPROM_Write (U16 address, U8 value)
  31          {
  32   1         U8 SFRPAGE_save = SFRPAGE;
  33   1         SFRPAGE = ACTIVE_PAGE;
  34   1      
  35   1         // Writing a byte to the EEPROM is a five-step operation.
  36   1      
  37   1         // Step1: Set the Write Enable Latch to 1
  38   1         NSSMD0   = 0;                       // Step1.1: Activate Slave Select
  39   1         SPI0DAT  = EEPROM_CMD_WREN;         // Step1.2: Send the WREN command
  40   1         while (!SPIF);                      // Step1.3: Wait for end of transfer
  41   1         SPIF     = 0;                       // Step1.4: Clear the SPI intr. flag
  42   1         NSSMD0   = 1;                       // Step1.5: Deactivate Slave Select
  43   1         Delay_us (1);                       // Step1.6: Wait for at least
  44   1                                             //          T_NSS_DISABLE_MIN
  45   1         // Step2: Send the WRITE command
  46   1         NSSMD0   = 0;
  47   1         SPI0DAT  = EEPROM_CMD_WRITE;
  48   1         while (!SPIF);
  49   1         SPIF     = 0;
  50   1      
  51   1         // Step3: Send the EEPROM destination address (MSB first)
  52   1         SPI0DAT  = (U8)((address >> 8) & 0x00FF);
  53   1         while (!SPIF);
C51 COMPILER V9.54   SPI                                                                   04/18/2025 16:51:39 PAGE 2   

  54   1         SPIF     = 0;
  55   1         SPI0DAT  = (U8)(address & 0x00FF);
  56   1         while (!SPIF);
  57   1         SPIF     = 0;
  58   1      
  59   1         // Step4: Send the value to write
  60   1         SPI0DAT  = value;
  61   1         while (!SPIF);
  62   1         SPIF     = 0;
  63   1         NSSMD0   = 1;
  64   1         Delay_us (1);
  65   1      
  66   1         // Step5: Poll on the Write In Progress (WIP) bit in Read Status Register
  67   1         do
  68   1         {
  69   2            NSSMD0   = 0;                    // Activate Slave Select
  70   2            SPI0DAT  = EEPROM_CMD_RDSR;      // Send the Read Status Register command
  71   2            while (!SPIF);                   // Wait for the command to be sent out
  72   2            SPIF     = 0;
  73   2            SPI0DAT  = 0;                    // Dummy write to output serial clock
  74   2            while (!SPIF);                   // Wait for the register to be read
  75   2            SPIF     = 0;
  76   2            NSSMD0   = 1;                    // Deactivate Slave Select after read
  77   2            Delay_us (1);
  78   2         } while((SPI0DAT & 0x01) == 0x01);
  79   1      
  80   1         SFRPAGE = SFRPAGE_save;
  81   1      }
  82          
  83          U8 EEPROM_Read (U16 address)
  84          {
  85   1         U8 spi_data;
  86   1      
  87   1         U8 SFRPAGE_save = SFRPAGE;
  88   1         SFRPAGE = ACTIVE_PAGE;
  89   1      
  90   1         // Reading a byte from the EEPROM is a three-step operation.
  91   1      
  92   1         // Step1: Send the READ command
  93   1         NSSMD0   = 0;                       // Activate Slave Select
  94   1         SPI0DAT  = EEPROM_CMD_READ;
  95   1         while (!SPIF);
  96   1         SPIF     = 0;
  97   1      
  98   1         // Step2: Send the EEPROM source address (MSB first)
  99   1         SPI0DAT  = (U8)((address >> 8) & 0x00FF);
 100   1         while (!SPIF);
 101   1         SPIF     = 0;
 102   1         SPI0DAT  = (U8)(address & 0x00FF);
 103   1         while (!SPIF);
 104   1         SPIF     = 0;
 105   1      
 106   1         // Step3: Read the value returned
 107   1         SPI0DAT  = 0;                       // Dummy write to output serial clock
 108   1         while (!SPIF);                      // Wait for the value to be read
 109   1         SPIF     = 0;
 110   1         NSSMD0   = 1;                       // Deactivate Slave Select
 111   1         Delay_us (1);
 112   1      
 113   1         spi_data = SPI0DAT;                 // Read data before restoring SFR page
 114   1      
 115   1         SFRPAGE = SFRPAGE_save;
C51 COMPILER V9.54   SPI                                                                   04/18/2025 16:51:39 PAGE 3   

 116   1      
 117   1         return spi_data;
 118   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    180    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       5
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
