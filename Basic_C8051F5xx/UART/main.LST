C51 COMPILER V9.54   MAIN                                                                  04/02/2025 16:44:56 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.exe main.c DB OE BR INCDIR(C:\SiLabs\MCU_4\Inc)

line level    source

   1          
   2          //-----------------------------------------------------------------------------
   3          // Includes
   4          //-----------------------------------------------------------------------------
   5          
   6          #include <compiler_defs.h>
   7          #include <C8051F580_defs.h>            // SFR declarations
   8          #include <stdio.h>
   9          
  10          //-----------------------------------------------------------------------------
  11          // Global CONSTANTS
  12          //-----------------------------------------------------------------------------
  13          
  14          #define SYSCLK      24000000           // SYSCLK frequency in Hz
  15          #define BAUDRATE      115200            // Baud rate of UART in bps
  16          
  17          //---------------SPI_DEFINE-----------------
  18          
  19          #define  F_SCK_MAX         2000000     // Max SCK freq (Hz)
  20          #define  T_NSS_DISABLE_MIN 500         // Min NSS disable time (ns)
  21          #define  EEPROM_CAPACITY   8        // EEPROM capacity (bytes)
  22          
  23          // EEPROM Instruction Set
  24          #define  EEPROM_CMD_READ   0x03        // Read Command
  25          #define  EEPROM_CMD_WRITE  0x02        // Write Command
  26          #define  EEPROM_CMD_WRDI   0x04        // Reset Write Enable Latch Command
  27          #define  EEPROM_CMD_WREN   0x06        // Set Write Enable Latch Command
  28          #define  EEPROM_CMD_RDSR   0x05        // Read Status Register Command
  29          #define  EEPROM_CMD_WRSR   0x01        // Write Status Register Command
  30          
  31          
  32          
  33          
  34          
  35          SBIT (LEDY, SFR_P2, 0);                 
  36          SBIT (LEDG, SFR_P2, 1);
  37          
  38          
  39          volatile unsigned long timeout_counter = 0;
  40          
  41          
  42          //--------------spi_d
  43          
  44          //-----------------------------------------------------------------------------
  45          // Function PROTOTYPES
  46          //-----------------------------------------------------------------------------
  47          
  48          void SYSCLK_Init (void);
  49          void UART1_Init (void);
  50          void PORT_Init (void);
  51          void SPI0_Init (void);
  52          void EEPROM_Write (U16 address, U8 value);
  53          U8 EEPROM_Read (U16 address);
  54          
  55          
C51 COMPILER V9.54   MAIN                                                                  04/02/2025 16:44:56 PAGE 2   

  56          void delay_ms(unsigned int ms);
  57          void Delay_us (U8 time_us);
  58          void Timer0_Init(void);
  59          void TIMER2_Init (void);
  60          
  61          
  62          
  63          //-----------------------------------------------------------------------------
  64          // MAIN Routine
  65          //-----------------------------------------------------------------------------
  66          
  67          void main (void)
  68          {
  69   1      
  70   1         SFRPAGE = ACTIVE_PAGE;
  71   1      
  72   1         PCA0MD &= ~0x40;                    // Disable watchdog timer
  73   1         PORT_Init();                        // Initialize Port I/O
  74   1         SYSCLK_Init ();                     
  75   1         UART1_Init();
  76   1         Timer0_Init();
  77   1         EA =1;
  78   1         SFRPAGE = ACTIVE2_PAGE;             // Switch page for UART1 communication
  79   1      
  80   1         while (1)
  81   1         {    U16 address;
  82   2                      U8 test_byte;
  83   2      
  84   2              //printf("Hello World\r\n");
  85   2                      //LEDY = ! LEDY;
  86   2                      //delay_ms(1000);
  87   2                      LEDY = 1;
  88   2                      printf("Filling with 0xFF's...\n");
  89   2                      for (address = 0; address < EEPROM_CAPACITY; address++)
  90   2                      {
  91   3                      test_byte = 0xFF;
  92   3                              //printf("Ok1");
  93   3                      EEPROM_Write (address, test_byte);
  94   3                              //printf("Ok2");                
  95   3                      // Print status to UART0
  96   3                      if ((address % 16) == 0)
  97   3                      {
  98   4                              printf ("\nWriting 0x%04x: %02x \r\n", address, (U16)test_byte);
  99   4                              LEDY = !LEDY;
 100   4                      }
 101   3                      else 
 102   3                      {
 103   4                              printf ("%02x ", (U16)test_byte); 
 104   4                      }
 105   3                      }
 106   2                      // Verify EEPROM with 0xFF's
 107   2                      printf("\n\nVerifying 0xFF's...\n");
 108   2                  for (address = 0; address < EEPROM_CAPACITY; address++)
 109   2                  {
 110   3                      test_byte = EEPROM_Read (address);
 111   3      
 112   3                    // Print status to UART0
 113   3                      if ((address % 16) == 0)
 114   3                      {       
 115   4                              printf ("\nVerifying 0x%04x: %02x ", address, (U16)test_byte);
 116   4                              LEDY = !LEDY;
 117   4                      }
C51 COMPILER V9.54   MAIN                                                                  04/02/2025 16:44:56 PAGE 3   

 118   3                      else
 119   3                      {
 120   4                              printf ("%02x ", (U16)test_byte);
 121   4                      }
 122   3      
 123   3                      if (test_byte != 0xFF)
 124   3                      {
 125   4                              LEDY = 0;
 126   4                              printf ("\nError at %u", address);
 127   4                              while (1);                    // Stop here on error (for debugging)
 128   4                      }
 129   3                      }
 130   2      
 131   2              }
 132   1              while (1)                           // Loop forever
 133   1         {
 134   2            LEDY = !LEDY;                      // Flash LED when done (all verified)
 135   2            delay_ms (1000);
 136   2         }
 137   1         
 138   1      }
 139          
 140          
 141          //-----------------------------------------------------------------------------
 142          // PORT_Init
 143          //-----------------------------------------------------------------------------
 144          
 145          void PORT_Init (void)
 146          {
 147   1         U8 SFRPAGE_save = SFRPAGE;
 148   1         SFRPAGE = CONFIG_PAGE;
 149   1              
 150   1              P0MDOUT   = 0x34;
 151   1          P0SKIP    = 0xC3;
 152   1      
 153   1          P1MDOUT |= 0x08;                    // Enable UART1 TX as push-pull output
 154   1          P0SKIP  = 0xFF;                     // Skip to P0, and P1.1,2,3
 155   1              P1SKIP = 0xE7;                                          // Enable UART1 on P1.3(TX) and P1.4(RX)
 156   1      
 157   1              P2MDOUT |= 0x03;                    // Enable LED as a push-pull output
 158   1          P2SKIP  |= 0xFC;
 159   1              
 160   1              //XBR0      = 0x04;
 161   1          XBR2    = 0x42;                     
 162   1                                             // Enable crossbar and weak pull-ups
 163   1          SFRPAGE = SFRPAGE_save;
 164   1      }
 165          
 166          //-----------------------------------------------------------------------------
 167          // SYSCLK_Init
 168          //-----------------------------------------------------------------------------
 169          
 170          void SYSCLK_Init (void)
 171          {
 172   1         U8 SFRPAGE_save = SFRPAGE;
 173   1         SFRPAGE = CONFIG_PAGE;
 174   1      
 175   1         OSCICN |= 0x87;                     // Configure internal oscillator for
 176   1                                             // its maximum frequency
 177   1         RSTSRC  = 0x04;                     // Enable missing clock detector
 178   1      
 179   1         SFRPAGE = SFRPAGE_save;
C51 COMPILER V9.54   MAIN                                                                  04/02/2025 16:44:56 PAGE 4   

 180   1      }
 181          void Timer0_Init(void)
 182          {
 183   1              
 184   1              TMOD &= 0xF0;
 185   1              TMOD |= 0x01; // timer 16bit
 186   1              CKCON |= 0x02;  // SYSCLK/48 = 500 kHz
 187   1              TH0 = (65536 - 500) >> 8;
 188   1              TL0 = (655536 -500) & 0xFF;
 189   1          ET0 = 1;               
 190   1          TR0 = 1;               
 191   1      }
 192          
 193          INTERRUPT(Timer0_ISR, INTERRUPT_TIMER0)
 194          {       
 195   1              TH0 = (65536 - 500) >> 8;
 196   1          TL0 = (65536 - 500) & 0xFF;
 197   1      
 198   1          timeout_counter++;
 199   1      }
 200          //-----------------------------------------------------------------------------
 201          // UART1_Init
 202          //-----------------------------------------------------------------------------
 203          
 204          void UART1_Init (void)
 205          {
 206   1         U8 SFRPAGE_save = SFRPAGE;
 207   1         SFRPAGE = ACTIVE2_PAGE;
 208   1      
 209   1         SCON1 = 0x10;                       // SCON1: 8-bit variable bit rate
 210   1      
 211   1         if (SYSCLK / BAUDRATE / 2 / 256 < 1) 
 212   1         {
 213   2            TH1 = -(SYSCLK / BAUDRATE / 2);
 214   2            CKCON &= ~0x0B;                  // T1M = 1; SCA1:0 = xx
 215   2            CKCON |=  0x08;
 216   2         } 
 217   1         else if (SYSCLK / BAUDRATE / 2 / 256 < 4) 
 218   1         {
 219   2            TH1 = -(SYSCLK / BAUDRATE / 2 / 4);
 220   2            CKCON &= ~0x0B;                  // T1M = 0; SCA1:0 = 01
 221   2            CKCON |=  0x01;
 222   2         } 
 223   1         else if (SYSCLK / BAUDRATE / 2 / 256 < 12) 
 224   1         {
 225   2            TH1 = -(SYSCLK / BAUDRATE / 2 / 12);
 226   2            CKCON &= ~0x0B;                  // T1M = 0; SCA1:0 = 00
 227   2         } 
 228   1         else 
 229   1         {
 230   2            TH1 = -(SYSCLK / BAUDRATE / 2 / 48);
 231   2            CKCON &= ~0x0B;                  // T1M = 0; SCA1:0 = 10
 232   2            CKCON |=  0x02;
 233   2         }
 234   1      
 235   1          TL1 = TH1;                          // Init Timer1
 236   1          TMOD &= ~0xF0;                      // TMOD: timer 1 in 8-bit autoreload
 237   1          TMOD |=  0x20;
 238   1          TR1 = 1;                            // START Timer1
 239   1      
 240   1          TI1 = 1;                            // Indicate TX0 ready (SCON1)
 241   1              //EIE2 |= 0x08;
C51 COMPILER V9.54   MAIN                                                                  04/02/2025 16:44:56 PAGE 5   

 242   1          SFRPAGE = SFRPAGE_save;
 243   1      }
 244          void TIMER2_Init(void)
 245          {
 246   1         // CKCON is available on all pages
 247   1      
 248   1         CKCON    |= 0x10;
 249   1      }
 250          
 251          
 252          
 253          void delay_ms(unsigned int ms)
 254          {
 255   1          unsigned long start = timeout_counter;
 256   1          while ((timeout_counter - start) < ms);
 257   1      }
 258          void Delay_us (U8 time_us)
 259          {
 260   1         U8 SFRPAGE_save = SFRPAGE;
 261   1         SFRPAGE = ACTIVE_PAGE;
 262   1      
 263   1         TR2   = 0;                          // Stop timer
 264   1         TF2H  = 0;                          // Clear timer overflow flag
 265   1         TMR2  = -((U16)(SYSCLK / 1000000) * (U16)(time_us));
 266   1         TR2   = 1;                          // Start timer
 267   1         while (!TF2H);                      // Wait till timer overflow occurs
 268   1         TR2   = 0;                          // Stop timer
 269   1      
 270   1         SFRPAGE = SFRPAGE_save;
 271   1      }
 272          void SPI0_Init()
 273          {
 274   1         U8 SFRPAGE_save = SFRPAGE;
 275   1         SFRPAGE = ACTIVE_PAGE;
 276   1      
 277   1         SPI0CFG   = 0x40;                   // Enable the SPI as a Master
 278   1                                             // CKPHA = '0', CKPOL = '0'
 279   1      
 280   1         SPI0CN    = 0x8D;                   // 4-wire, single master mode
 281   1                                             // SPI0 enable
 282   1      
 283   1         // The equation for SPI0CKR is (SYSCLK/(2*F_SCK_MAX))-1, but this yields
 284   1         // a SPI frequency that is slightly more than 2 MHz. But, 2 MHz is the max
 285   1         // frequency spec of the EEPROM used here. So, the "-1" term is omitted
 286   1         // in the following usage:
 287   1         SPI0CKR   = (SYSCLK / (2 * F_SCK_MAX));
 288   1      
 289   1         SFRPAGE = SFRPAGE_save;
 290   1      }
 291          
 292          void EEPROM_Write (U16 address, U8 value)
 293          {
 294   1         U8 SFRPAGE_save = SFRPAGE;
 295   1         SFRPAGE = ACTIVE_PAGE;
 296   1      
 297   1         // Writing a byte to the EEPROM is a five-step operation.
 298   1      
 299   1         // Step1: Set the Write Enable Latch to 1
 300   1         NSSMD0   = 0;                       // Step1.1: Activate Slave Select
 301   1         SPI0DAT  = EEPROM_CMD_WREN;         // Step1.2: Send the WREN command
 302   1         while (!SPIF);                      // Step1.3: Wait for end of transfer
 303   1         SPIF     = 0;                       // Step1.4: Clear the SPI intr. flag
C51 COMPILER V9.54   MAIN                                                                  04/02/2025 16:44:56 PAGE 6   

 304   1         NSSMD0   = 1;                       // Step1.5: Deactivate Slave Select
 305   1         Delay_us (1);                       // Step1.6: Wait for at least
 306   1                                             //          T_NSS_DISABLE_MIN
 307   1         // Step2: Send the WRITE command
 308   1         NSSMD0   = 0;
 309   1         SPI0DAT  = EEPROM_CMD_WRITE;
 310   1         while (!SPIF);
 311   1         SPIF     = 0;
 312   1      
 313   1         // Step3: Send the EEPROM destination address (MSB first)
 314   1         SPI0DAT  = (U8)((address >> 8) & 0x00FF);
 315   1         while (!SPIF);
 316   1         SPIF     = 0;
 317   1         SPI0DAT  = (U8)(address & 0x00FF);
 318   1         while (!SPIF);
 319   1         SPIF     = 0;
 320   1      
 321   1         // Step4: Send the value to write
 322   1         SPI0DAT  = value;
 323   1         while (!SPIF);
 324   1         SPIF     = 0;
 325   1         NSSMD0   = 1;
 326   1         Delay_us (1);
 327   1      
 328   1         // Step5: Poll on the Write In Progress (WIP) bit in Read Status Register
 329   1         do
 330   1         {
 331   2            NSSMD0   = 0;                    // Activate Slave Select
 332   2            SPI0DAT  = EEPROM_CMD_RDSR;      // Send the Read Status Register command
 333   2            while (!SPIF);                   // Wait for the command to be sent out
 334   2            SPIF     = 0;
 335   2            SPI0DAT  = 0;                    // Dummy write to output serial clock
 336   2            while (!SPIF);                   // Wait for the register to be read
 337   2            SPIF     = 0;
 338   2            NSSMD0   = 1;                    // Deactivate Slave Select after read
 339   2            Delay_us (1);
 340   2         } while((SPI0DAT & 0x01) == 0x01);
 341   1      
 342   1         SFRPAGE = SFRPAGE_save;
 343   1      }
 344          
 345          //-----------------------------------------------------------------------------
 346          // EEPROM_Read
 347          //-----------------------------------------------------------------------------
 348          //
 349          // Return Value : The value that was read from the EEPROM
 350          //                   range: 0x00 to 0xFF
 351          // Parameters   : 1. address - the source EEPROM address.
 352          //                   range: 0 to EEPROM_CAPACITY
 353          //
 354          // Reads one byte from the specified EEPROM address.
 355          //
 356          //-----------------------------------------------------------------------------
 357          U8 EEPROM_Read (U16 address)
 358          {
 359   1         U8 spi_data;
 360   1      
 361   1         U8 SFRPAGE_save = SFRPAGE;
 362   1         SFRPAGE = ACTIVE_PAGE;
 363   1      
 364   1         // Reading a byte from the EEPROM is a three-step operation.
 365   1      
C51 COMPILER V9.54   MAIN                                                                  04/02/2025 16:44:56 PAGE 7   

 366   1         // Step1: Send the READ command
 367   1         NSSMD0   = 0;                       // Activate Slave Select
 368   1         SPI0DAT  = EEPROM_CMD_READ;
 369   1         while (!SPIF);
 370   1         SPIF     = 0;
 371   1      
 372   1         // Step2: Send the EEPROM source address (MSB first)
 373   1         SPI0DAT  = (U8)((address >> 8) & 0x00FF);
 374   1         while (!SPIF);
 375   1         SPIF     = 0;
 376   1         SPI0DAT  = (U8)(address & 0x00FF);
 377   1         while (!SPIF);
 378   1         SPIF     = 0;
 379   1      
 380   1         // Step3: Read the value returned
 381   1         SPI0DAT  = 0;                       // Dummy write to output serial clock
 382   1         while (!SPIF);                      // Wait for the value to be read
 383   1         SPIF     = 0;
 384   1         NSSMD0   = 1;                       // Deactivate Slave Select
 385   1         Delay_us (1);
 386   1      
 387   1         spi_data = SPI0DAT;                 // Read data before restoring SFR page
 388   1      
 389   1         SFRPAGE = SFRPAGE_save;
 390   1      
 391   1         return spi_data;
 392   1      }
 393          //-----------------------------------------------------------------------------
 394          // End Of File
 395          //-----------------------------------------------------------------------------
*** WARNING C294 IN LINE 219 OF main.c: unreachable code


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    631    ----
   CONSTANT SIZE    =    116    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      4       9
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
